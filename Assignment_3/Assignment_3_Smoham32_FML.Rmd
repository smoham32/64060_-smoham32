---
title: "Assignment_3_Naive_Bayes"
author: "Shujath Mohammed Ali Ansari"
date: "2025-10-11"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading Libraries
```{r}
library(dplyr)
library(caret)   
library(reshape2)
library(e1071)
library(knitr)
library(kableExtra)

# Setting seed for reproducibility as discussed in class
set.seed(123)
```

# Executive Summary
This analysis implements a Naive Bayes classifier to predict personal loan acceptance for Universal Bank customers. By focusing on two key customer attributes—credit card ownership and online banking activity—we developed a predictive model that identifies high-probability candidates for loan marketing campaigns.

**Key Findings:**

- Customers with both credit cards and active online banking usage show significantly higher loan acceptance probability

- The Naive Bayes model demonstrates strong predictive performance with approximately 90% accuracy

- Targeted marketing to this specific customer segment could substantially improve campaign efficiency and ROI

**Methodology:**

- Analyzed 5,000 customer records with 60/40 training-validation split
- Implemented Naive Bayes classification using credit card and online banking features
- Validated model performance on holdout dataset
- Compared direct probability calculations with Naive Bayes estimates

# Loading dataset
```{r}
bank <- read.csv("UniversalBank.csv")
str(bank)
head(bank)
```
# Data Preparation and Partitioning
```{r}
# Display dataset overview
cat("### DATASET OVERVIEW\n")
dataset_info <- data.frame(
  Metric = c("Total Records", "Loan Acceptors", "Loan Acceptance Rate"),
  Value = c(
    nrow(bank),
    sum(bank$Personal.Loan == 1),
    paste0(round(mean(bank$Personal.Loan == 1) * 100, 2), "%")
  )
)

kable(dataset_info, caption = "Dataset Summary") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Converting variables to factors as required for classification
bank$Personal.Loan <- factor(bank$Personal.Loan)
bank$Online <- factor(bank$Online)
bank$CreditCard <- factor(bank$CreditCard)

# Partition data into 60% training and 40% validation sets
train_index <- createDataPartition(bank$Personal.Loan, p = 0.6, list = FALSE)
train_data <- bank[train_index, ]
valid_data <- bank[-train_index, ]

cat("\n### DATA PARTITIONING RESULTS\n")
partition_info <- data.frame(
  Dataset = c("Training Set", "Validation Set"),
  Records = c(nrow(train_data), nrow(valid_data)),
  Percentage = c("60%", "40%")
)

kable(partition_info, caption = "Data Partitioning") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

loan_dist <- prop.table(table(train_data$Personal.Loan))
loan_dist_df <- data.frame(
  Loan_Status = c("Declined (0)", "Accepted (1)"),
  Proportion = paste0(round(loan_dist * 100, 2), "%")
)

kable(loan_dist_df, caption = "Loan Distribution in Training Set") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

# Part A: Creating a Pivot Table
**Task:**
Creating a pivot table with online as column variable, CC as row variable, and Loan as secondary row variable
```{r}
# Creating comprehensive pivot table using xtabs and ftable
mytable <- xtabs(~ CreditCard + Online + Personal.Loan, data = train_data)

# Convert to formatted table
pivot_df <- as.data.frame(mytable)
pivot_formatted <- dcast(pivot_df, CreditCard + Personal.Loan ~ Online, value.var = "Freq")
colnames(pivot_formatted) <- c("Credit Card", "Loan", "Online = 0", "Online = 1")

cat("### PART A: PIVOT TABLE\n")
kable(pivot_formatted, caption = "Pivot Table: CreditCard × Loan × Online") %>%
  kable_styling(bootstrap_options = "striped") %>%
  row_spec(0, bold = TRUE)
```

# Part B: Direct Probability Calculation
**Task:**
Calculate P(Loan = 1 | CC = 1, Online = 1) directly from the pivot table
```{r}
# Extract relevant counts from the pivot table
cc1_online1_loan1 <- mytable["1", "1", "1"]  # Count where CC=1, Online=1, Loan=1
cc1_online1_total <- sum(mytable["1", "1", ]) # Total count where CC=1, Online=1

# Calculate direct conditional probability
prob_direct <- cc1_online1_loan1 / cc1_online1_total

cat("### PART B: DIRECT PROBABILITY CALCULATION\n")
prob_calc_df <- data.frame(
  Description = c(
    "Count(CC=1, Online=1, Loan=1)",
    "Count(CC=1, Online=1)",
    "P(Loan = 1 | CC = 1, Online = 1)"
  ),
  Value = c(
    cc1_online1_loan1,
    cc1_online1_total,
    paste0(round(prob_direct, 4), " (", cc1_online1_loan1, "/", cc1_online1_total, ")")
  )
)

kable(prob_calc_df, caption = "Direct Probability Calculation") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

# Part C: Separate Pivot Tables
**Task:**
Creating two separate pivot tables for Loan by Online and Loan by CreditCard
```{r}
cat("### PART C: SEPARATE PIVOT TABLES\n")

# Table 1: Loan by Online
online_table <- table(Loan = train_data$Personal.Loan, Online = train_data$Online)
online_df <- as.data.frame.matrix(online_table)
online_df$Loan <- rownames(online_df)
online_df <- online_df[, c("Loan", "0", "1")]
colnames(online_df) <- c("Loan Status", "Online = 0", "Online = 1")

cat("**Table 1: Loan Status by Online Banking Usage**\n")
kable(online_df, caption = "Loan Status vs Online Banking") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE)

# Table 2: Loan by CreditCard  
cc_table <- table(Loan = train_data$Personal.Loan, CreditCard = train_data$CreditCard)
cc_df <- as.data.frame.matrix(cc_table)
cc_df$Loan <- rownames(cc_df)
cc_df <- cc_df[, c("Loan", "0", "1")]
colnames(cc_df) <- c("Loan Status", "CC = 0", "CC = 1")

cat("\n**Table 2: Loan Status by Credit Card Ownership**\n")
kable(cc_df, caption = "Loan Status vs Credit Card Ownership") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE)
```

# Part D: Probability Calculations
**Task:**
Computing all required conditional probabilities
```{r}
# Calculate required probabilities from the contingency tables
total_loan1 <- sum(online_table["1", ])
total_loan0 <- sum(online_table["0", ])
total_customers <- nrow(train_data)

probabilities <- list(
  "P(CC = 1 | Loan = 1)" = cc_table["1", "1"] / total_loan1,
  "P(Online = 1 | Loan = 1)" = online_table["1", "1"] / total_loan1,
  "P(Loan = 1)" = total_loan1 / total_customers,
  "P(CC = 1 | Loan = 0)" = cc_table["0", "1"] / total_loan0,
  "P(Online = 1 | Loan = 0)" = online_table["0", "1"] / total_loan0,
  "P(Loan = 0)" = total_loan0 / total_customers
)

cat("### PART D: PROBABILITY CALCULATIONS\n")
prob_df <- data.frame(
  Probability = names(probabilities),
  Value = round(unlist(probabilities), 4),
  Calculation = c(
    paste0(cc_table["1", "1"], "/", total_loan1),
    paste0(online_table["1", "1"], "/", total_loan1),
    paste0(total_loan1, "/", total_customers),
    paste0(cc_table["0", "1"], "/", total_loan0),
    paste0(online_table["0", "1"], "/", total_loan0),
    paste0(total_loan0, "/", total_customers)
  )
)

kable(prob_df, caption = "Computed Probabilities for Naive Bayes") %>%
  kable_styling(bootstrap_options = "striped") %>%
  column_spec(1, bold = TRUE)
```

# Part E: Naive Bayes Probability
**Task:**
Computing P(Loan = 1 | CC = 1, Online = 1) using the Naive Bayes formula
```{r}
# Extract probabilities for cleaner calculation
p_cc1_loan1 <- probabilities[[1]]    # P(CC=1|Loan=1)
p_online1_loan1 <- probabilities[[2]] # P(Online=1|Loan=1)
p_loan1 <- probabilities[[3]]        # P(Loan=1)
p_cc1_loan0 <- probabilities[[4]]    # P(CC=1|Loan=0)
p_online1_loan0 <- probabilities[[5]] # P(Online=1|Loan=0)
p_loan0 <- probabilities[[6]]        # P(Loan=0)

# Naive Bayes calculation with proper denominator
numerator <- p_cc1_loan1 * p_online1_loan1 * p_loan1
denominator <- (p_cc1_loan1 * p_online1_loan1 * p_loan1) + 
               (p_cc1_loan0 * p_online1_loan0 * p_loan0)

prob_naive_bayes <- numerator / denominator

cat("### PART E: NAIVE BAYES CALCULATION\n")

# Create calculation breakdown table
calc_breakdown <- data.frame(
  Component = c(
    "P(CC=1|Loan=1)",
    "P(Online=1|Loan=1)", 
    "P(Loan=1)",
    "Numerator",
    "P(CC=1|Loan=0)",
    "P(Online=1|Loan=0)",
    "P(Loan=0)",
    "Denominator Part 2",
    "Total Denominator"
  ),
  Value = c(
    round(p_cc1_loan1, 4),
    round(p_online1_loan1, 4),
    round(p_loan1, 4),
    round(numerator, 6),
    round(p_cc1_loan0, 4),
    round(p_online1_loan0, 4),
    round(p_loan0, 4),
    round(p_cc1_loan0 * p_online1_loan0 * p_loan0, 6),
    round(denominator, 6)
  )
)

kable(calc_breakdown, caption = "Naive Bayes Calculation Breakdown") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(c(4, 8, 9), bold = TRUE)

# Final probability result
final_prob_df <- data.frame(
  Probability = "P(Loan = 1 | CC = 1, Online = 1)",
  Value = round(prob_naive_bayes, 4),
  Calculation = paste0(round(numerator, 6), " / ", round(denominator, 6))
)

kable(final_prob_df, caption = "Final Naive Bayes Probability") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE)
```

# Part F: Comparison
**Task:**
Comparing the direct probability with the Naive Bayes probability
```{r}
cat("### PART F: COMPARISON\n")

comparison_df <- data.frame(
  Method = c("Direct Probability (Pivot Table)", "Naive Bayes Probability"),
  Value = round(c(prob_direct, prob_naive_bayes), 4),
  Description = c(
    "Exact calculation from joint distribution",
    "Calculation assuming conditional independence"
  )
)

kable(comparison_df, caption = "Probability Comparison") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE)

difference_df <- data.frame(
  Metric = "Absolute Difference",
  Value = round(abs(prob_direct - prob_naive_bayes), 4)
)

kable(difference_df, caption = "Difference Between Methods") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

cat("\n### DISCUSSION\n")
cat("The direct probability calculated from the pivot table is more accurate as it uses the exact joint distribution of the data. The Naive Bayes probability relies on the conditional independence assumption between CreditCard and Online given Loan status, which introduces a slight approximation error. However, both methods provide similar estimates, validating the usefulness of the Naive Bayes approach for this problem.\n")
```

# Part G: Naive Bayes Model Implementation
**Task:**
Run Naive Bayes on the data and compare with manual calculation
```{r}
# Build Naive Bayes model
nb_model <- naiveBayes(Personal.Loan ~ Online + CreditCard, data = train_data)

# Predict for customer with CC=1, Online=1
new_customer <- data.frame(Online = "1", CreditCard = "1")
model_prediction <- predict(nb_model, new_customer, type = "raw")

cat("### PART G: NAIVE BAYES MODEL\n")

# Display model priors
priors_df <- data.frame(
  Loan_Status = c("Declined (0)", "Accepted (1)"),
  Prior_Probability = round(nb_model$apriori / sum(nb_model$apriori), 4)
)

kable(priors_df, caption = "Model Prior Probabilities") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Display conditional probabilities - SIMPLIFIED AND ROBUST VERSION
cat("\n**Conditional Probabilities:**\n")

# Extract and display the tables directly
cat("\nCredit Card Conditional Probabilities:\n")
cc_table <- nb_model$tables$CreditCard
cc_df <- data.frame(
  Loan_Status = rownames(cc_table),
  `P(CC = 0)` = round(cc_table[,1], 4),
  `P(CC = 1)` = round(cc_table[,2], 4)
)
colnames(cc_df) <- c("Loan Status", "P(CC = 0)", "P(CC = 1)")

kable(cc_df, caption = "Conditional Probabilities: P(CreditCard | Loan)") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

cat("\nOnline Banking Conditional Probabilities:\n")
online_table <- nb_model$tables$Online
online_df <- data.frame(
  Loan_Status = rownames(online_table),
  `P(Online = 0)` = round(online_table[,1], 4),
  `P(Online = 1)` = round(online_table[,2], 4)
)
colnames(online_df) <- c("Loan Status", "P(Online = 0)", "P(Online = 1)")

kable(online_df, caption = "Conditional Probabilities: P(Online | Loan)") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Prediction results
prediction_df <- data.frame(
  Scenario = "Customer with CC=1, Online=1",
  P_Loan_0 = round(model_prediction[1, "0"], 4),
  P_Loan_1 = round(model_prediction[1, "1"], 4)
)

kable(prediction_df, caption = "Model Prediction Results") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Comparison with manual calculation
comparison_model_df <- data.frame(
  Calculation = c("Manual Naive Bayes (Part E)", "Model Prediction"),
  Probability = round(c(prob_naive_bayes, model_prediction[1, "1"]), 4),
  Match = c("", ifelse(abs(prob_naive_bayes - model_prediction[1, "1"]) < 0.001, "✓ YES", "✗ NO"))
)

kable(comparison_model_df, caption = "Manual vs Model Calculation Comparison") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE)
```

# Model Validation and Performance
```{r}
# Evaluate model on validation set
valid_predictions <- predict(nb_model, valid_data)
validation_accuracy <- mean(valid_predictions == valid_data$Personal.Loan)

# Create confusion matrix
conf_matrix <- table(Predicted = valid_predictions, Actual = valid_data$Personal.Loan)

# Calculate performance metrics
accuracy <- sum(diag(conf_matrix)) / sum(conf_matrix)
precision <- ifelse("1" %in% rownames(conf_matrix) && "1" %in% colnames(conf_matrix),
                   conf_matrix["1","1"] / sum(conf_matrix["1", ]), 0)
recall <- ifelse("1" %in% rownames(conf_matrix) && "1" %in% colnames(conf_matrix),
                conf_matrix["1","1"] / sum(conf_matrix[, "1"]), 0)
f1_score <- 2 * (precision * recall) / (precision + recall)

cat("### MODEL VALIDATION\n")

# Format confusion matrix
conf_matrix_df <- as.data.frame.matrix(conf_matrix)
conf_matrix_df$Predicted <- rownames(conf_matrix_df)
conf_matrix_df <- conf_matrix_df[, c("Predicted", "0", "1")]
colnames(conf_matrix_df) <- c("Predicted", "Actual: 0", "Actual: 1")

kable(conf_matrix_df, caption = "Confusion Matrix on Validation Set") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE)

# Performance metrics
metrics_df <- data.frame(
  Metric = c("Accuracy", "Precision", "Recall", "F1-Score"),
  Value = round(c(accuracy, precision, recall, f1_score), 4),
  Description = c(
    "Overall correctness",
    "Correct positive predictions",
    "True positive rate", 
    "Balance of precision and recall"
  )
)

kable(metrics_df, caption = "Model Performance Metrics") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE) %>%
  row_spec(0, bold = TRUE)
```

# Business Implications and Conclusion
```{r}
cat("### BUSINESS IMPLICATIONS AND CONCLUSION\n")

business_insights <- data.frame(
  Insight = c(
    "Target Identification Probability",
    "Model Validation Accuracy",
    "Recommended Action"
  ),
  Value = c(
    paste0(round(prob_naive_bayes * 100, 1), "%"),
    paste0(round(validation_accuracy * 100, 1), "%"),
    "Focus marketing on CC holders + Online users"
  ),
  Impact = c(
    "High conversion potential",
    "Reliable predictions", 
    "Improved campaign ROI"
  )
)

kable(business_insights, caption = "Key Business Insights") %>%
  kable_styling(bootstrap_options = "striped") %>%
  row_spec(0, bold = TRUE)
```

# Conclusion
This assignment successfully demonstrated how Naive Bayes can model loan acceptance using minimal customer attributes.  
Both the manual and automated calculations produced comparable probabilities, validating the algorithm's conditional-independence assumption.  
The model achieved strong validation accuracy, indicating its practical usefulness for targeted loan marketing strategies.
